CPS 3.0

 Informations

  Version: $Version$

  Date: $Date$

  Id: $Id$

 Conventions

  Nommages

   - Produits : le nom des produits commencent TOUS par "NuxCPS" et le nom est,
     a priori, calculé sur le nom de la classe principale présente dans le
     produit, si c'est le cas.

   - Classes : Afin de bien distinguer les classes génériques crées par Nuxeo
     des classes spécifiques développées pour le client, les noms de classes
     doivent posséder un préfixe de 2 lettres majuscules. Les classes
     génériques commencent par "NX", les classes spécifiques, pour la Défense
     par exemple, commencent par "DF".

   - Meta-type :

    - Tools : les "tools" CMF doivent posséder un meta-type de la forme
      "CPS *XXX* Tool"

    - Documents : le meta-type est de la forme "CPS *XXX* Document"

    - Proxies : le meta-type est de la forme "CPS *XXX* Proxy" (à définir s'il
      y a plusieurs types de proxy)

    - Objets fonctionnels : le meta-type est de la forme "CPS *XXX* Object"

    - Variables : à définir

    - Nom des page templates : à définir

  Fichiers et répertoires obligatoires

   On doit trouver dans un produit les fichiers et répertoires suivants :

   - COPYING.txt : la GPL in extenso.

   - LICENCE.txt : texte court rappelant la GPL et incitant à consulter
     COPYING.txt

   - COPYRIGHT.txt : la liste des copyrights. En premier Nuxeo, suivent les
     sponsors.

   - README.txt : un bref descriptif du produit en Anglais.

   - LISEZMOI.txt : un bref descriptif du produit en Français.

   - tests : les tests unitaires. On trouve dans ce répertoire un scripts
     "makeTests" qui effectue tous les tests unitaires.

   - skins : les skins. Ce répertoire doit contenir au moins un répertoire
     correspondant à la skin principale du produit. Ne pas mettre, donc, dans
     "skins" directement les fichiers pour les Page Templates, Scripts Python,
     etc.

   - zmi : les fichiers spécifiques pour la ZMI.

   - doc : les documentations

   Sera fourni à ce propos un script de création rapide d'un produit,
   d'un fichier python, d'un script python.

   Pas de fichier "version.txt". Ce fichier est produit au moment de la
   release.

 Unicode

  CPS 3.0 doit supporter au maximum Unicode.

  Code

   - procédures de codage à suivre pour supporter Unicode (XXX à écrire)

  Exemples

   - (XXX à écrire)

 Produits

  Centre de Notification

   - Nom proposé :

    NuxCPSNotificationCenterTool

   - Classe principale :

    NXNotificationCenterTool

    meta_type : "CPS Notification Center Tool"

    id : "portal_notification"

    abrégé : "nctool"

   - Description :

    Point central pour enregistrer tous les événements. Ce centre de
    notifications dispatche ensuite ces notifications d'événements à d'autres
    objets/services. Toute appel à une méthode doit enregistrer l'événement
    dans le centre de notification, que ce soit la visualisation, l'édition,
    la publication d'un document.

    Le centre de notification doit pouvoir regrouper plusieurs occurrences
    d'une même notification dans la même requête et doit pouvoir déclencher
    les événements hors de la requête (ce qui peut améliorer les performances
    du site ou permettre d'envoyer un *digest* des modifications de la
    journée).

   Cas d'utilisation :

    - Modification d'un objet/document. La modification d'un objet/document
      enverra une notification au centre de notifications qui effectuera alors
      un mailing aux personnes concernées. On retrouve ce genre d'exemple pour
      la soumission/publication/dépublication d'un document.

    - On doit, de même, pouvoir utiliser ce genre de notifications lors de la
      visualisation d'un document. On peut imaginer ensuite que cette
      information permettra de déterminer quels documents un utilisateur doit
      encore lire, ou prévenir une personne de la lecture d'un document par
      une autre personne.

  Éléments

   - Nom proposé :

    NuxCPSElementsTool

   - Classe principale :

    NXElementsTool

    meta_type : "CPS Elements Tool"

    id : "portal_elements"

    abrégé : "eltool"

   - Description :

    Ce produit est à considérer essentiellement d'un point de vue
    "développeur".

    Ce produit permet essentiellement de pouvoir régler finement le
    comportement des différents éléments (graphiques ou non) permettant de
    construire la réponse d'une requête. Il fournit, de plus,
    un espace de nom global à toute la requête plus facilement éditable
    (et "surchageable") et accessible que celui défini par exemple
    avec CPS 2.0 dans *main_template.pt*.

    Les différents éléments utilisés pour construire cette réponse utilisent
    d'autres éléments qui, eux-mêmes, peuvent utiliser d'autres éléments.

    Avec ce système, on peut espérer pouvoir traiter finement le cache de
    certains "morceaux" de la page, d'avoir une totale souplesse de la
    disposition des éléments graphiques sur la page, de pouvoir déléguer la
    liste, position de tout ou partie des éléments à un autre objet, etc. On
    peut ajouter des éléments ou surcharger certains éléments.

    Afin de bien distinguer les éléments dans le code, le nom des éléments
    sera en capitales.

   - Exemples d'utilisation :

    L'API utilisée n'est pas obligatoirement l'API définitive mais une
    idée de ce qui sera présenté au développeur et d'éventuellement
    en dégager l'intérêt.

    On trouvera un certain nombre d'éléments par défaut disponibles. Par
    exemple :

    - HERE : désigne l'endroit courant accédé ;

    - PORTAL : la racine du portail ;

    - DISPLAY : l'élément principal construisant une page complète ;

    - WIDGETS : les widgets disponibles dans CPS ;

    - etc. (XXX sûrement d'autres à prévoir... typiquement toutes les variables
      définies actuellement dans *main_template* de CPS 2).

    On peut imaginer le code classique de certains éléments :

    DISPLAY est un script python ::

     ##parameters=elements_container=None

     if elements_container is None:
         REQUEST = context.REQUEST
         elements_container = REQUEST['elements_container']
     else:
         REQUEST = elements_container['REQUEST']

     if REQUEST.get('pp', 0):
         # on demande la page en version imprimable
         return context.main_printable(elements_container=elements_container)
     else:
         # version classique
         return context.main_display(elements_container=elements_container)
     
    avec le code pour *main_display.pt* ::

     <html tal:define="ec options/elements_container">
     <head>
       <title tal:content="ec/PAGE_TITLE">Page Title</title>
       <base tal:attributes="href ec/BASE_HREF" />
       <tal:block repeat="style ec/all/STYLES" replace="style" />
       <tal:block repeat="script ec/all/SCRIPTS" replace="script" />
     </head>
     <body>
       <tal:block replace="ec/BANNER" />

       <br>

       Action courante : <tal:block replace="ec/CURRENT_ACTION" />

       <br>

       <tal:block repeat="content ec/all/CONTENTS">
         <tal:block replace="content" />
         <hr tal:content="not:repeat/content/end" />
       </tal:block>
     </body>
     </html>

    et enfin le *document_view* d'un document quelconque ::

     ##parameters=REQUEST

     portal_elements = context.portal_elements

     # on initialise et on récupère le conteneur d'éléments
     ec = portal_elements.getElementsContainer(here=context, request=REQUEST)

     # on ajoute le résultat de l'action "content_view" à la liste
     # d'éléments "CONTENTS"
     ec.addActionCallElement('CONTENTS', context, 'content_view')

     # on calcule l'élément DISPLAY
     return ec['DISPLAY'](elements_container=ec)

    On peut aussi imaginer le "workgroup_view" permettant l'affichage d'un
    espace de travail ::

     ##parameters=REQUEST

     portal_elements = context.portal_elements

     ec = portal_elements.getElementsContainer(here=context, request=REQUEST)

     ec.addElements('DOCUMENTS', context.contentValues())

     isAnon = ec['ISANON']

     if not isAnon:
         # l'utilisateur n'est pas anonyme, le type d'affichage
         # est retrouvé par défaut dans l'espace (ou
         # par acquisition)
         work_type = REQUEST.SESSION.get('work_type')
         if work_type = None:
             work_type = getattr(context, 'work_type', None)
             if work_type is None:
                 work_type = 'manage'
     else:
         # L'utilisateur est anonyme, l'élément "CONTENTS" ne sera
         # que l'affichage de l'espace en mode 'visit'
         work_type = 'visit'

     if work_type == 'visit':
         # On accède à l'espace en tant que visiteur
         # On affiche alors juste la liste des documents
         # "list_documents" récupère les objets à lister dans l'élément
         # "DOCUMENTS"
         ec.addCallElement('CONTENTS', context, 'list_documents')

     elif work_type == 'manage':
         # On est en mode "administration", on obtient alors la vue de l'espace
         # qui permet de manier les objets.
         ec.addCallElements('CONTENTS', context, 'manage_documents')

     return ec['DISPLAY'](elements_container=ec)

  Espaces

   Description :

    Dans CPS 3.0, il n'y a plus de distinction nette entre espaces de travail
    et espaces de publication. Un espace contient physiquement les documents,
    ou plutôt un proxy vers les documents.
    
    En premier lieu, il convient de déterminer le nom que l'on donnerait
    à ces "espaces" en Anglais afin de pouvoir déterminer le nom du
    produit et des classes.

    Il faut définir les rôles régissant les différents droits sur l'espace.
    Une première idée est :

     - Manager : gère les droits et publie les documents ;

     - ActiveMember : crée des documents dans l'état privé ;

     - PassiveMember : crée un proxy d'un document dont il a la gestion
       dans l'état privé (= soumission d'un document) ;

     - Visitor : peut lire les documents dans l'état "public".

    Un espace peut restreindre localement les types de documents autorisés.

    Un espace peut avoir un/des délégués pour certaines actions de
    visualisation (à préciser. Voir NuxCPSElementsTool).

    Il est sûrement souhaitable d'avoir un système de "template" d'espace
    qui permet d'ajouter des espaces-types avec objets associés
    (un forum, un canevas, des portlets, liste des types de documents
    autorisés, etc.).

  Portlets

   - Nom proposé :

    NuxCPSPortletsTool

   - Classe principale :

    NXPortletsTool

    meta_type : "CPS Portlets Tool"

    id : "portal_portlets"

    abrégé : "pltool"

   - Description :

    Ce produit permet de gérer les boîtes qui apparaissent dans la page. Il
    s'appuye en partie sur les éléments disponibles.

    Il doit être possible de définir des portlets globaux et des portlets
    locaux. Un utilisateur référencé doit pouvoir ajouter des portlets
    "globaux", éventuellement disponibles selon son environnement
    (consultation/édition) ou changer certaines propriétés des portlets
    déjà définies (visibilité, minimisation, etc.).

    On doit pouvoir modifier le style d'une portlet.

   - Cas d'utilisation :

    Un administrateur de rubrique/sous-site (ou le site entier) change
    le canevas de la rubrique/sous-site (ou le site entier).

    Cet administrateur modifie les portlets affichées dans le canevas.

    Il ajoute un portlet à afficher dans le canevas :

    - il doit pouvoir choisir l'emplacement du portlet

    - il doit pouvoir choisir le décor du portlet

    - il doit pouvoir choisir l'affichage dans le portlet (exemple :
      boite de listes de documents affichée en mode étendu, en mode
      compact, en mode minimal, etc.)

    - il ne doit pas pouvoir "casser" l'affichage de la page. Le HTML
      doit rester non seulement correct mais "lisible". Le but est
      d'assurer au maximum la robustesse de l'interface. Il se peut donc
      que certains décors soient interdits à certains emplacement du canevas.
      Mieux, il se peut que certains types d'affichage soient interdits
      (impossible d'afficher une liste de documents en mode étendu
      dans des boites prévues pour être peu larges...)

   - Idées :

    NuxCPSPortlets doit gérer :

    - les canevas de page

     Le canevas définit les emplacements où peuvent se trouver les portlets
     et pour chaque emplacement les décors possibles. Il donne aussi le
     HTML à utiliser pour afficher effectivement le canevas ainsi
     qu'une vue synthétique du canevas (pour l'interface d'administration
     des portlets).

    - les décors des portlets

     Le décor d'un portlet définit le HTML qui va afficher effectivement
     le portlet. À la différence de NuxPortal dans CPS 2.0, les portlets
     ne doivent pas fournir le rendu du HTML du contenu des portlets
     sauf cas spécial (du genre "Text Box"... et encore).

     Un décor doit donc définir quelles sont les "fonctionnalités" attendues
     de la boite (la boite fournit une liste de liens, un arbre d'objet,
     tout simplement du HTML, etc.) et pourra alors au moment de l'affichage
     mettre en forme les données fournies par le portlet.

     Plus précisémment un même décor doit avoir lui-même plusieurs styles,
     chaque style précisant les fonctionnalités requises par la boite pour
     que ce style puisse s'appliquer.

     Exemple :
     
      Décor "Boite Gauche" :
       
       Style "Contenu brut" :

        fonctionnalités requises : ("Title" ou "HTMLTitle") et "HTMLBody"

       Style "Liste compacte" :

        fonctionnalités requises : ("Title" ou "HTMLTitle") et "DocInfos"

       Style "Liste étendue" :

        fonctionnalités requises : ("Title" ou "HTMLTitle") et "DocInfos"

       Style "Liste d'actions en block" :

        fonctionnalités requises : ("Title" ou "HTMLTitle") et "ActionsBlocks"

       Style "Liste d'actions" :

        fonctionnalités requises : ("Title" ou "HTMLTitle") et "ActionsList"

    - les portlets

     Les portlets fournissent les données passées au décor dans le format
     que le décor sait mettre en forme. Une portlet doit donc contenir
     tout le code pour calculer ces données et aussi fournir les
     différents "formats" qu'il est succeptible de renvoyer. Cette liste
     de format est ordonnée et le décor doit choisir le format le plus
     adapté au portlet.

     On peut donc ajouter un portlet à un emplacement du canevas s'il existe
     au moins un décor possible pour l'emplacement donné et que pour ce
     décor il existe au moins un style pour lequel le portlet fournit toutes
     les fonctionnalités requises.

     Exemple :

      Portlet "Text Portlet" :

       fonctionnalités fournies : ("Title", "HTMLBody")

      Portlet "Document Portlet" :

       fonctionnalités fournies : ("Title", "DocInfos")

      Portlet "Navigation Portlet" :

       fonctionnalités fournies : ("HTMLTitle", "Title",
        "Hierarchical Navigation List")

      Portlet "Quick Links Portlet" :

       fonctionnalités fournies : ("Title", "ActionsList", "HTMLBody")

       (pour l'exemple, un portlet "Quick Link Portlet" peut donner
       sous forme de liste HTML ses liens)

      Portlet "Ad Portlet" :

       fonctionnalités fournies : ("ImageAndLink")

     Supposons que dans l'emplacement "Colonne Gauche" du canevas, seul
     le décor "Boite Gauche" soit autorisé, on ne pourra y ajouter que
     les portlets "Text Portlet", "Document Portlet", et "Quick Links Portlet".

     Si on y ajoute un "Document Portlet", on pourra alors choisir le
     style "Liste compacte" et "Liste étendue".

     Si on y ajoute un "Quick Links Portlet", on pourra choisir le
     style "Contenu brut" ou "Liste d'actions". Dans le premier cas, il
     utilisera la fonctionnalité "ActionsList" pour afficher les liens
     dans le body de la boite, dans le deuxième il utilisera la fonctionnalité
     "HTMLBody" (avec un rendu alors bien-sûr moins adapté au décor).

    Dans les faits, comment stocker tout cela ? Le principe veut que :

    - On puisse ajouter des instances de canevas / portlets dans un conteneur
      A et si l'on est dans le conteneur A/B, on utilise par défaut les
      canevas/portlets de A. On peut aussi ajouter un canevas dans A/B,
      remplaçant celui de A. Ce canevas peut automatiquement utiliser des
      portlets de A (portlets déclarés comme héritable), retirer des
      portlets hérités de A, ajouter des portlets (éventuellement héritable
      dans la sous-hierarchie de A/B).

    - Un utilisateur peut ajouter ses propres portlets globaux qui se
      retrouveront dans tout le site.

    - Un utilisateur peut créer des "pages" dans son espaces privé avec
      ses propres canevas afin d'avoir ses pages dynamiques affichant
      des informations sélectionnées (dans la veine de my.yahoo.com).
    
   D'un point de vue développeur :

    Il faut que définir tout cela soit le plus simple possible pour le
    développeur. Le moteur des portlets doit s'occuper de tout le reste :

    - interface d'administration des canevas et portlets

    - rendu effectif des canevas et des portlets

    Le développeur ne devra définir plusiseurs choses :

    - le type de canevas :

     - une ZPT qui assure le rendu effectif du canevas

     - un (ou deux) fichier annexe qui définit la liste logique des
       emplacements disponibles dans le canevas, pour chaque emplacement
       la liste des décors possibles et finalement une "vue schématique"
       du canevas (pour l'interface d'administration)

    - les décors :
    
     - une ZPT qui assure le rendu effectif du portlet utilisant au mieux
       les fonctionnalités du portlet

     - un fichier annexe qui définit pour le décor la liste des
       styles déclarant alors les fonctionnalités attendues des portlets.
       Ce fichier peut aussi donner des "propriétés" de décor supplémentaires
       (couleur, image, etc. à préciser)

    - les portlets :

     une classe CMF complète (classe + fti) + la liste des fonctionnalités
     fournies par ce type (cette liste devrait logiquement se trouver
     dans la déclaration de la classe comme _properties pour
     PropertyManager) + les propriétés réglables du portlet et bien-sûr les
     méthodes spécifiques pour le fonctionnement du portlet.

  Base documentaire

   - Nom proposé :

    NuxCPSDocumentsRepositoryTool

   - Classe principale :

    NXDocumentsRepositoryTool

    meta_type : "CPS Documents Repository Tool"

    id : "portal_documents"

    abrégé : "doctool"

   - Description :

    Ce produit doit permettre de gérér la (ou les) base(s) documentaire(s)
    du portail. Tous les documents sont regroupés à un même endroit, pris
    en charge par ce produit.

    On doit pouvoir gérer les documents présents suivant certains paramètres
    comme la version ou la langue de façon souple et indépendante.

    Chaque document doit avoir un identifiant unique.

    Ce produit doit aussi apporter le type de base à tous les documents
    devant être stockés dans la base documentaire. Plus exactement, un
    type de base pour les documents et un type de base pour les proxies.

    En ce qui concerne les discussions associées, il est sûrement préférable
    de les sortir du document et les placer dans un forum associé à l'espace
    dans lequel le proxy se trouve. On peut donc avoir des fils de discussion
    différents selon les endroits (ou pas de discussion possible).  Par
    exemple, une dicussion portant sur le document pour les personnes
    le modifiant et un fil de discussion privé ou public dans le ou les
    espaces où le document se trouve publié.

    Il n'est peut-être pas souhaitable que tous les documents/objets
    utilisent le mécanisme de "publication virtuelle" (ou plutôt de
    "présence virtuelle"). En particulier, les forums ou les objets
    fonctionnels ne sont pas des documents à stocker dans la base
    documentaire centrale (ils peuvent cependant utiliser un mécanisme de
    base documentaire, cela est sûrement souhaitable).

 Patches

  Il est presque irrémédiable de patcher CMF d'une manière ou d'une autre.

  La première question est : regroupe-t-on tous les patches dans le même
  produit ?

  Sinon, quelques patches envisagés :

  - Comme dans CPS 2.0, un patch pour la création d'espace privé (qu'il soit
    d'un type défini par nous, éventuellement pre-loaded)

  - Un patch semble nécessaire pour le TypesTool afin de pouvoir ajouter
    des propriétés à un portal_type ("allow discussion" en est un exemple et
    il est d'ailleurs anormal que ce soit une propriété codée en dur) mais
    aussi ajouter des propriétés aux actions (une image associée, d'éventuelle
    propriétés "onclick" pour le rendu HTML, etc.)
