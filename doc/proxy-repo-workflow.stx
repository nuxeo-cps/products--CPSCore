Proxies, document repository and workflows

  This document attempts to describe the workings of proxies, the
  document repository and workflows.

  This is still a work in progress.

  Vocabulary

    I call "workspace" a place where documents are usually created and
    worked on, and "section" a place where documents are put after
    publication so that the site's anonymous or general users can see
    them.

  Internationalization

    Site languages are managed through a Localizer instance at the root
    of the portal, which must be named 'Localizer' . The default
    language in Localizer will be the default language for the
    documents.

  Proxies

    A proxy is a placeholder for a document (either contentish or
    folderish), living in the user-visible tree of the site. It points
    to other documents, which means that virtually a same document can
    be in several places in the whole tree, with different workflow
    states in each.

    A proxy:

    - has a portal_type,

    - has a docid, which is the identifier of the set of documents
      (differentiated by their rev) to which this proxy is related,

    - has a mapping of language -> rev, where language can be 'fr' or
      'en' for instance; rev is an integer. Together (docid, rev)
      identify a unique document's revision in the document repository,

    - has a default language, which is used for instance to find what
      language to display if the user language is not available,

    - has security information applied to it to control its visibility,
      depending on its workflow state.

  Document repository

    The document repository stores all version of all documents in the
    site. "Document" means anything that has to be versionned, so this
    may include for instance the section folders themselves.

    A document in the repository has:

    - a docid, which is a string,

    - a rev (revision), which is an integer; several documents may be
      present with the same docid but different rev,

    - a portal_type, which makes it possible to associate actions to it,
      for instance for the different views,

    - generally, all the attributes describing the "content" of the
      document,

    - security information to control for instance its visibility (View)
      and modifiability (Modify portal content) (according to the
      workflow). The security information is the union of all the
      settings of the proxies that point to it.

    A revision may be internally "frozen", which means that it won't
    ever be modified again. In this state, it's not modifiable. This
    frozen state exists for all revisions corresponding to a workflow
    state that is frozen. This is used to ensure that a given published
    revision, for instance, is not modified. "Freezing" a revision must
    be understood as "mark this revision as to be lazily copied for any
    future modification".

    In addition, whenever a document is created in a given language, its
    'setLanguage' method is called to initialize the language.

  Document views

    What a user sees when he's browsing the site at a given URL is the
    proxy object at that URL, but it has to be displayed using the data
    that is stored somewhere in the repository. This means that for all
    processing relating to the object's location, the proxy has to be
    used, but for all content-related processing the document in the
    repository has to be used.

    Especially, the ZPT views of the document have to take both into
    account.

    The proxy object ('here' in ZPT) must be used for:

    - absolute_url(),

    - getId(), title_or_id(),

    - objectIds(), objectValues(), objectItems(), when access to
      subobjects of a folderish object is needed,

    - breadcrumb computations.

    The document repository object (tal:define="doc here/getContent")
    must be used for:

    - any method (edit(), getProperty()),

    - any data accessor (Title(), Description(), etc.).

    Because the views for a portal type must have meaning when applied
    to a proxy object, all views must be provided by CMF skins. Having
    the view being directly implemented as a method in the python class
    of the CMF object won't work, as all views will be applied to
    proxies from CMF's point of view.

  Edition

    When a document is published in a section, it keeps the same
    revision as the one in the workspace from which it has been
    published, so that there are not too many versions. But the revision
    is marked "frozen", because by being published there is a promise to
    the section reviewer that the document won't change without his
    review. When the author wants to modify his document in the
    workspace, the system must provide a new revision. This is done
    automatically when needed, by using::

      doc = context.getEditableContent()

    instead of::

      doc = context.getContent()

    This way, because we advise CPS that we're about to modify a
    revision, it's possible to create a new revision when needed.

  Placeful workflow configuration

    In CPS workflows are placeful, this means that we can decide that
    for a given subtree, a given portal_type will follow a given
    workflow. A placeful (local) workflows is used for instance to have
    a subtree dedicated to public content where objects must pass
    through a reviewing process, and another subtree where the objects
    can be created and worked upon easily by the members.

    To create a placeful workflow configuration, a 'CPS Workflow
    Configuration' object must be crated in the ZMI. It's then possible
    to define for each portal type what workflow it has to follow.

    When a workflow is configured in a folder, it applies to the folder
    itself and all its subobjects, recursively. Sometimes we want to
    configure a workflow for all the subobjects of a folder but not for
    the folder itself. This can be done using a "Below workflow chain".

  Workflows

    The workflows are based on DCWorkflow with some extensions.

    Workflows control all the operations of a site, and all the security
    checks.

    A number of transition flags have been added to DCWorkflow. These
    flags govern some special CPS behavior of the transition. They can
    be subdivded in several categories.

    Allowing subobject behavior

      A container has responsibility for globally allowing certain
      behaviors for its subobjects. This covers creation, deletion,
      moving into the container, copying into the container, publishing
      into the container, checkout into the container.

      Once a container allows certain operation, the workflow for the
      portal type itself will have to allow the operation too.

      Some of these behavior are checked by the manage_CPScopyObjects,
      manage_CPScutObjects and manage_CPSpasteObjects methods. This will
      be integrated into core Zope methods later.

    Initial transitions

      An initial transition is a transition followed when an object is
      created (or published, checked out, etc.) in a container. It does
      not have an initial state, but the destination state is the one
      the object will have after creation. When asking for the creation
      of a portal type, only those that have a suitable initial
      transition will be allowed. The standard "initial state" of
      DCWorkflow is not used.

      "Transition for checkin" is logically grouped together with those.
      It's a transition an object will follow when it is on the
      receiving end of a checkin (i.e., when it is the reference object
      into which a modification is checked back in).

    Specific behavior

      - "Freeze object" is used by all transitions going to a state
        where the object should not be modified anymore. This may in the
        future move to be a property of the state itself.

      - "Publishing, with initial transitions" is used as a mechanism
        for publishing an object into another container.

      - "Checkout, with initial transitions" is used to checkout an
        object into another container.

      - "Checkin, with allowed transitions" is used to checkin an object
        back into its original version.

  Publishing

    The term "Publishing" is used here to represent any kind of
    operation that involves taking a document in a workspace and
    requesting its publication in a section.

    In such an operation, two containers are used, which means two
    workflows. There is a source workflow for the document, that has to
    have a "publishing" operation, and in the destination container two
    conditions must be met: the destination container has to allow
    subobject publising (note that local roles of the source container
    have no meaning in the destination container), and the destination
    workflow for the portal type of the document has to have some
    initial transition for publishing, which will be used when the
    document is "published" or "submitted" in the section. The guards
    (conditions) on these initial transitions express who is authorized
    to do which initial transition, and can thus distinguish between a
    "submit" and a direct "publish".

    Note: a way to take into account the local roles of the source
    container will maybe have to be devised in the future.

    The 'doActionFor' call for a publishing transition takes 2
    arguments, 'dest_container' and 'initial_transition'. They describe
    the destination container into which the publishing must occur, and
    the initial transition to follow there. This initial transition will
    be validated against the allowed initial transitions specified in
    the workflow.

  Checkout and checkin

    Checkout and checkin are a way to take a document from a reference
    version, make modifications to it, and fold back the modifications
    into the original.

    The 'doActionFor' call for a checkout operation takes 2 mandatory
    arguments, 'dest_container', 'initial_transition' and an optional
    'language_map'. The first two are similar to what happens for
    publishing, and 'language_map' is a mapping of new languages to old
    languages, used to specify what languages will appear in the checked
    out document and what language they are based on. This can be used
    to checkout a version into a new language for translation. If
    'language_map' is not present, then all languages are copied.

    The 'doActionFor' call for a checkin operation takes 2 arguments,
    'dest_object' and 'checkin_transition'. They describe the
    destination object into which to merge changes, and the checkin
    transition this destination object will follow after changes are
    merged.

    Note that after a checkin the working document is deleted.

  Document lifecycle

    This is an attempt to describe the lifecycle of a document. It
    assumes a site set up with two areas, one which is the workspaces,
    with folders of portal_type Workspace, where authors create and
    modify content, and one area which is the hierarchical public
    sections, where folders have portal_type Section.

    There is a workspace document workflow (actually one for each
    content portal_type), which describes the workflow followed by
    documents when they are being worked upon.

    There is a section document workflow (for each portal_type), which
    describes the fact that documents go through a submission process
    before being published.

    There is a workflow for Section themeselves, which permits the
    versionning of the changes to a section's title and description.

    Story

      A document is created

        In a workspace, a new document of portal_type News is created.
        This is possible because the workflow for Workspace allows
        subobject creation, and because the workspace workflow for News
        has an initial transition.

        In the workspace a proxy 'mydoc' with portal_type News is
        created, it points for all languages to docid 'abcd' with
        version 1. In the document repository, a document with docid
        'abcd' and version 1 is created, it has portal_type News. It
        contains the document's data.

      The document is viewed...

      The document is edited

        The scripts that edit the document have to call
        context.getEditableContent before doing modifications, to ensure
        that the revision used is really modifiable.

        ...

      The document is submitted to a section.

        This is possible because the workspace workflow for News allows
        object "cloning" into other folders. To know in what section it
        can be submitted or published, all sections are examined and
        asked if objects can be created in them, and what cloning
        initial transitions they have for News. The user then choses a
        section among the possible ones.

        The submission process itself consits of the creation of a
        revision of the document in the document repository, and the
        creation of a proxy to that revision in the section. The current
        revision is used, but because the "pending" state in the section
        is a "frozen" state, which means that no other editable version
        of that document is allowed to exist (to ensure that the
        reviewer sees a non-editable document), the revision is marked
        "frozen". In other kinds of workflows, this wouldn't be needed.

      A reviewer reviews the document

        The section reviewer sees a new submitted document. To know that
        the reviewer has something to review, the catalog is queried for
        all documents in the "pending" state.

        When the reviewer decides to publish the document, the
        corresponding workflow transition is invoked and the proxy
        changes state.

      The original document is edited

        Because the revision is frozen, just before the edit script does
        its modification, the call to getEditableContent will replace
        the revision in the proxy in the workspace with a new editable
        revision, and it is that revision that will be used from now on.

      The revised document is re-submitted

        The submission process is the same. Now after submission, the
        section contains one version in the published state, and another
        version in the pending state. The reviewer, when reviewing the
        document, will be informed of that fact and may chose to reject
        the newly submitted version (which means simply removing the
        proxy), or publish the new version and remove the previous one.

        Having two versions of the same document in the published state
        should be avoided in a section workflow. This can be avoided by
        skin code that checks for these cases.
