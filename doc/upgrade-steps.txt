=============
Upgrade steps
=============

:Revision: $Id$

.. contents:: :depth: 1
.. sectnum::

It will be convenient for examples to have a pretty printer::

    >>> from pprint import PrettyPrinter
    >>> pretty_print=PrettyPrinter(width=50).pprint


Categories registration
=======================

The CPSCore product has already registered a category::

    >>> from Products.CPSCore.upgrade import _categories_registry
    >>> pretty_print(_categories_registry)
    {'cpsplatform': {'description': '',
                     'floor_version': '3.2.0',
                     'portal_attr': 'last_upgraded_version',
                     'title': 'CPS Platform'}}


    Let's add one as if we were managing a side component.

    >>> from Products.CPSCore.upgrade import registerUpgradeCategory
    >>> registerUpgradeCategory('my_app',
    ...                 title='My Application',
    ...                 floor_version='0.5',
    ...                 description='My very cool app on top of CPS',
    ...                 portal_attribute='my_app_up_version')
    >>> pretty_print(_categories_registry['my_app'])
    {'description': 'My very cool app on top of CPS',
     'floor_version': '0.5',
     'portal_attr': 'my_app_up_version',
     'title': 'My Application'}

    We can also specify a reference product for the upgrade
    category by means of the ``ref_product`` keyword argument. The
    current code version will be stored as well.

    We need to cheat a bit to avoid the example to rely on CPSCore's
    version at the time of this writing::

    >>> import os
    >>> from Products.CPSCore import upgrade
    >>> upgrade.VERSION_FILE = os.path.join('tests', 'data', 'VERSION.sample')

    Now let's go::

    >>> registerUpgradeCategory('my_app2',
    ...                 title='My Application',
    ...                 floor_version='0.1',
    ...                 ref_product='CPSCore',
    ...                 description='My very cool app on top of CPS',
    ...                 portal_attribute='my_app2_up_version')
    >>> pretty_print(_categories_registry['my_app2'])
    {'code_version': '19.0.0',
     'description': 'My very cool app on top of CPS',
     'floor_version': '0.1',
     'portal_attr': 'my_app2_up_version',
     'ref_product': 'CPSCore',
     'title': 'My Application'}
    >>> del _categories_registry['my_app2']


   ``code_version`` can be used, e.g., by site factories to set the
   database version at site creation time. It is normally read from the
   VERSION file that should sit at the topmost level of the reference
   product. Without the above monkey patching, we would have gotten
   CPSCore's version.

Upgrade steps registration
==========================

In python
~~~~~~~~~

Code ::

    >>> class SimplestConfigurationContext:
    ...     def action(self, discriminator, callable=None, args=()):
    ...         """Do it now!"""
    ...         if callable is not None:
    ...             callable(*args)

    >>> context = SimplestConfigurationContext()
    >>> from Products.CPSCore.upgrade import upgradeStep, _upgrade_registry

    So, let's register a step for 'My Application'::

    >>> def up_my_app_1_0_1_1(portal):
    ...     print "my_app: 1.0 -> 1.1"
    >>> upgradeStep(context, 'Test Step 1', up_my_app_1_0_1_1,
    ...             category='my_app',
    ...             source='1.0',
    ...             destination='1.1', sortkey=10)

    Now, let's see if we can find it in the list of proposed steps 'My
    Application'::

    >>> from Products.CPSCore.upgrade import listUpgradeSteps
    >>> portal = None
    >>> [step['title'] for step in listUpgradeSteps(portal, 'my_app', (1, 0))]
    ['Test Step 1']


In ZCML
~~~~~~~

Use the <cps:upgradeStep> element. Mandatory attributes 'title'
and 'handlers' corrspond to positional args of the upgradeStep function,
while others correspond to kwargs (see also various examples
within CPS configuration)


Listing
~~~~~~~

Code::

    >>> def up_my_app_1_1_1_2(portal):
    ...     print "my_app: 1.1 -> 1.2"
    >>> upgradeStep(context, 'Test Step 3', up_my_app_1_1_1_2,
    ...             category='my_app',
    ...             source='1.1',
    ...             destination='1.2', sortkey=10)

    >>> def up_my_app_1_1_1_2first(portal):
    ...     print "my_app: 1.1 -> 1.2 (first)"
    >>> upgradeStep(context, 'Test Step 2', up_my_app_1_1_1_2first,
    ...             category='my_app',
    ...             source='1.1',
    ...             destination='1.2', sortkey=6)

    >>> def up_my_app_1_2_2_0(portal):
    ...     print "my_app: 1.2 -> 2.0"
    >>> upgradeStep(context, 'Test Step 4', up_my_app_1_2_2_0,
    ...             category='my_app',
    ...             source='1.2',
    ...             destination='2.0', sortkey=10,
    ...             requires='cpsplatform-3.4.5')


    >>> steps = listUpgradeSteps(None, 'my_app', (1, 0))

    Let's remove some human non friendly data and display the ordered
    list of proposed steps::

    >>> for step in steps:
    ...     del step['id']
    ...     del step['step']
    >>> pretty_print(steps)
    [{'dest': (1, 1),
      'proposed': True,
      'source': (1, 0),
      'title': 'Test Step 1'},
     {'dest': (1, 2),
      'proposed': True,
      'source': (1, 1),
      'title': 'Test Step 2'},
     {'dest': (1, 2),
      'proposed': True,
      'source': (1, 1),
      'title': 'Test Step 3'},
     {'dest': (2, 0),
      'proposed': True,
      'requires': ('cpsplatform', (3, 4, 5)),
      'source': (1, 2),
      'title': 'Test Step 4'}]

    It's also possible to bound the destination version from above
    (see #2250)::

    >>> steps = listUpgradeSteps(None, 'my_app', (1, 0), max_dest=(1, 2))
    >>> [step['title'] for step in steps]
    ['Test Step 1', 'Test Step 2', 'Test Step 3']



Setup Tool
==========

Code::

    >>> class FakePortal:
    ...     pass
    >>> portal = FakePortal()
    >>> class FakeUrlTool:
    ...     def getPortalObject(self):
    ...         return portal
    >>> portal.portal_url = FakePortal()
    >>> from Products.CPSCore.setuptool import CPSSetupTool
    >>> tool = CPSSetupTool()
    >>> tool.portal_url = FakeUrlTool()

    The version is kept as a property on the portal object. If
    missing, the category's floor version is used::

    >>> tool._getCurrentVersion('my_app')
    (0, 5)

    The tool provides an API to update the version number.
    >>> tool._setCurrentVersion('my_app', (1, 0))
    '1.0'
    >>> tool._getCurrentVersion('my_app')
    (1, 0)

    >>> pretty_print(tool._getUpgradeCategoryDisplayInfo('my_app'))
    {'description': 'My very cool app on top of CPS',
     'id': 'my_app',
     'title': 'My Application',
     'version': '1.0'}

    Views have to use the following method::

    >>> pretty_print(tool.listUpgradeCategories())
    [{'description': '',
      'id': 'cpsplatform',
      'title': 'CPS Platform',
      'version': '3.2.0'},
     {'description': 'My very cool app on top of CPS',
      'id': 'my_app',
      'title': 'My Application',
      'version': '1.0'}]

Upgrades proposals
~~~~~~~~~~~~~~~~~~

Code::

    >>> list_ups = tool.listUpgrades(category='my_app')
    >>> [up['title'] for up in list_ups]
    ['Test Step 1', 'Test Step 2', 'Test Step 3']

    Our test step 4 was not proposed because it requires (the upgrade of)
    CPSPlatform to 3.4.5. Let's see what info is provided for each step::

    >>> pretty_print(list_ups[0].keys())
    ['source',
     'step',
     'proposed',
     'title',
     'dest',
     'haspath',
     'ssource',
     'id',
     'sdest']


    Now, let's do as if we were on 1.1: step 1 shouldn't be presented anymore::

    >>> tool._setCurrentVersion('my_app', (1, 1))
    '1.1'
    >>> list_ups = tool.listUpgrades(category='my_app')
    >>> [up['title'] for up in list_ups]
    ['Test Step 2', 'Test Step 3']
    >>> tool._setCurrentVersion('my_app', (1, 2))
    '1.2'
    >>> tool.listUpgrades(category='my_app')
    []

    Now we pretend that CPSPlatform has been upgraded to the required
    version for step 4::

    >>> tool._setCurrentVersion('cpsplatform', (3, 4, 5))
    '3.4.5'
    >>> list_ups = tool.listUpgrades(category='my_app')
    >>> [up['title'] for up in list_ups]
    ['Test Step 4']

    The result would be the same for a later version::

    >>> tool._setCurrentVersion('cpsplatform', (3, 5))
    '3.5'
    >>> list_ups = tool.listUpgrades(category='my_app')
    >>> [up['title'] for up in list_ups]
    ['Test Step 4']

    Dependency requirement is implicit for all steps after one that
    has some::

    >>> def up_my_app_2_0_3_0():
    ...     print "my_app: 2.0 -> 3.0"
    >>> upgradeStep(context, 'Test Step 5', up_my_app_2_0_3_0,
    ...             category='my_app',
    ...             source='2.0',
    ...             destination='3.0')
    >>> tool._setCurrentVersion('cpsplatform', (3, 4, 4))
    '3.4.4'
    >>> tool.listUpgrades(category='my_app')
    []

Launching the upgrades
======================

Code::

    >>> tool._setCurrentVersion('my_app', (1, 1))
    '1.1'
    >>> list_ups = tool.listUpgrades(category='my_app')
    >>> ids = [up['id'] for up in list_ups]
    >>> tool.doUpgrades(ids, 'my_app')
    my_app: 1.1 -> 1.2 (first)
    my_app: 1.1 -> 1.2

    The stored version was updated:

    >>> tool._getCurrentVersion('my_app')
    (1, 2)

.. Emacs
.. Local Variables:
.. mode: rst
.. End:
.. Vim
.. vim: set filetype=rst:
